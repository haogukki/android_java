### 架构组件

https://www.cnblogs.com/Android-Alvin/

https://github.com/googlecodelabs/

#### 重点

```java
app架构指南
组件生命周期，LifeCycle-aware组件
数据持久化，LiveData, Room, 
异步任务，workManager
```

#### 难点

```java
理解组件生命周期
了解数据持久化相关类使用场景
了解异步任务
```

#### 预习问题

##### 1、MVVM架构是什么？
###### 概念

Model-View-ViewModel的简称，MVVM模式将应用分为三层：Model层主要负责数据的提供，View层主要负责界面的显示，ViewModel层主要负责业务逻辑的处理。各个层职责单一，结构清晰，应用可以很方便地进行测试、维护和扩展。

<img src="pics/mvvm.png" alt="mvvm" style="zoom:50%;" />

- **Model层**，主要负责数据的提供。Model层提供业务逻辑的数据结构（比如，实体类），提供数据的获取（比如，从本地数据库或者远程网络获取数据），提供数据的存储。
- **View层**，主要负责界面的显示。View层不涉及任何的业务逻辑处理，它持有ViewModel层的引用，当需要进行业务逻辑处理时通知ViewModel层。
- ViewModel层，主要负责业务逻辑的处理。ViewModel层不涉及任何的视图操作。通过官方提供的Data Binding库，View层和ViewModel层中的数据可以实现绑定，ViewModel层中数据的变化可以自动通知View层进行更新，因此ViewModel层不需要持有View层的引用。ViewModel层可以看作是View层的数据模型和Presenter层的结合。

https://blog.csdn.net/u012317510/article/details/80247756

###### 其他架构

<img src="pics/mvc_mvp.png" alt="mvc_mvp.png" style="zoom:33%;" />

MVC

- View：布局的xml文件，或者纯Java写的布局，可以把页面显示的逻辑直接放在View中。
- Model：数据处理层，可以直接和View进行交互。
- Controller：把特定的功能逻辑抽离出来，作为控制层，保证View层和Model层的功能单一性，便于维护。

MVP

- View：Activity：作为显示层。
- Presenter：逻辑层，从Activity中抽离出功能逻辑，简化Activity的代码。
- Model：数据处理层，主要负责网络请求，本地数据加载等操作，进一步简化Activity的代码。

https://blog.csdn.net/u011315960/article/details/82869206

######  对比

##### 2、架构组件的使用场景

架构组件LiveData, Room, ViewModel, Paging, Navigation 使用场景

###### LiveData

https://blog.csdn.net/gdutxiaoxu/article/details/86660760

[`LiveData`](https://developer.android.google.cn/reference/androidx/lifecycle/LiveData) 是`一种可观察的数据存储器类`，它可以感知 Activity、Fragment或Service 等组件的生命周期。

- 它可以做到在组件处于激活状态的时候才会回调相应的方法，从而刷新相应的 UI。
- 当担心发生内存泄漏的时候
- 当 config 导致 activity 重新创建的时候，不需要手动取处理数据的储存和恢复。它已经帮我们封装好了。
- 当 Actiivty 不是处于激活状态的时候，如果你想 livedata setValue 之后立即回调 obsever 的 onChange 方法，而不是等到 Activity 处于激活状态的时候才回调 obsever 的 onChange 方法，你可以使用 observeForever 方法，但是你必须在 onDestroy 的时候 removeObserver。

例如：回想一下，在你的项目中，是不是经常会碰到这样的问题，当网络请求结果回来的时候，你经常需要判断 Activity 或者 Fragment 是否已经 Destroy， 如果不是 destroy，才更新 UI。而当你如果使用 Livedata 的话，因为它是在 Activity 处于 onStart 或者 onResume 的状态时，他才会进行相应的回调，因而可以很好得处理这个问题，不必写一大堆的 activity.isDestroyed()

###### Room

https://www.jianshu.com/p/654d883e6ed0

Room是Google推出的Android架构组件库中的数据持久化组件库, 也可以说是在SQLite上实现的一套ORM解决方案。Room主要包含三个部分：

- **Database** : 持有DB和DAO
- **Entity** : 定义POJO类，即数据表结构
- **DAO**(Data Access Objects) : 定义访问数据（增删改查）的接口

<img src="pics/room.png" alt="room" style="zoom:50%;" />

在SQLite API方式实现数据持久化的项目中，相信都有一个任务繁重的`SQLiteOpenHelper`实现, 一堆维护表的字段的`Constant`类， 一堆代码类似的数据库访问类（DAO），访问数据库时需要做Cursor的遍历，构建并返回对应的POJO类...相比之下，Room作为在SQLite之上封装的ORM库确实有诸多优势。

- 比SQLite API更简单的使用方式
- 省略了许多重复代码
- 能在编译时校验sql语句的正确性
- 数据库相关的代码分为Entity, DAO, Database三个部分，结构清晰
- 简单安全的数据库升级方案

###### ViewModel

是负责准备和管理和UI组件(Fragment/Activity)相关的数据类，也就是说ViewModel是用来管理UI相关的数据的，同时ViewModel还可以用来负责UI组件间的通信。ViewModel用来存储和管理UI相关的数据，可于将一个Activity或Fragment组件相关的数据逻辑抽象出来，并能适配组件的生命周期，如当屏幕旋转Activity重建后，ViewModel中的数据依然有效。

通常Android系统来管理UI controllers（如Activity、Fragment）的生命周期，由系统响应用户交互或者重建组件，用户无法操控。当组件被销毁并重建后，原来组件相关的数据也会丢失，如果数据类型比较简单，同时数据量也不大，可以通过onSaveInstanceState()存储数据，组件重建之后通过onCreate()，从中读取Bundle恢复数据。但如果是大量数据，不方便序列化及反序列化，则上述方法将不适用。
UI controllers经常会发送很多异步请求，有可能会出现UI组件已销毁，而请求还未返回的情况，因此UI controllers需要做额外的工作以防止内存泄露。
当Activity因为配置变化而销毁重建时，一般数据会重新请求，其实这是一种浪费，最好就是能够保留上次的数据。
UI controllers其实只需要负责展示UI数据、响应用户交互和系统交互即可。但往往开发者会在Activity或Fragment中写许多数据请求和处理的工作，造成UI controllers类代码膨胀，也会导致单元测试难以进行。我们应该遵循职责分离原则，将数据相关的事情从UI controllers中分离出来。

- ViewModel职责是为Activity或Fragment管理、请求数据，具体数据请求逻辑不应该写在ViewModel中，否则ViewModel的职责会变得太重，此处- 需要一个引入一个Repository，负责数据请求相关工作。具体请参考 Android架构组件。

-  ViewModel可以用于Activity内不同Fragment的交互，也可以用作Fragment之间一种解耦方式。
-  ViewModel也可以负责处理部分Activity/Fragment与应用其他模块的交互。
-  ViewModel生命周期（以Activity为例）起始于Activity第一次onCreate()，结束于Activity最终finish时。

https://www.cnblogs.com/Android-Alvin/p/12109378.html

###### Paging

分页技术，Paging的主要功能就是一次加载小部分数据，可以减少网络带宽和系统资源的使用

###### Navigation

Google 在2018年推出了的Android Jetpack里的一种管理fragment的架构模式`navigation`. 字面意思是导航,但是除了做APP引导页面以外.也可以使用在App主页分tab的情况，甚至可以一个功能模块就一个activity大部分页面UI都使用fragment来实现,而navigation就成了管理fragment至关重要的架构。但是,它不单单只能管理fragment也可以管理activity。

3、WorkManager执行异步任务的优势是什么

WorkManager是google提供的异步执行任务的管理框架，会根据手机的API版本和应用程序的状态来选择适当的方式执行任务。当应用在运行的时候会在应用的进程中开一条线程来执行任务，当退出应用时，WorkManager会选择根据设备的API版本使用适合的算法调用JobScheduler或者Firebase JobDispatcher,或者AlarmManager来执行任务。
<center class="half">
<img src="pics/workmanager1.png" alt="mvvm" style="zoom:50%;" />
<img src="pics/workmanager2.png" width = "50%" alt="workmanager2" align=right />
<center>

使用 WorkManager 实现可延期、可靠的工作，WorkManager 适用于**可延期**工作，即不需要立即运行但需要**可靠运行**的工作，即使用户退出或设备重启也不受影响。例如：

- 向后端服务发送日志或分析数据
- 定期将应用数据与服务器同步

WorkManager 不适用于应用进程结束时能够安全终止的运行中后台工作，也不适用于需要立即执行的工作。
https://www.cnblogs.com/Android-Alvin/p/12109545.html

### 导航组件