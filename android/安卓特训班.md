### 作业

28号下午

1、创建首个应用并实现两个activity切换

29号上午

2.1、编写一个展示图片的demo,在不同配置的（至少使用四种资源限定符）目录下，放置不同的图片，要求系统在任意请款下改都能获取到匹配的资源
2.2、预演不同配置下demo展示的图片，然后实际操作验证
3、编写一个可以编辑文本的Demo,尝试在屏幕旋转导致activity重建时，保存当前输入文本

29号下午

1.如何适配720P、1080P、2K下的图片资源？
2.定义一组字符串并适配英语、法语、阿拉伯语、西班牙语，在demo中读取定义的资源，并通过adb shell在模拟器上调试

30号上午

1、编写一个至少使用颜色状态列表、Drawble、布局、字符串（带符号参数）、颜色、尺寸六种资源的Demo
2、编写一个三段式的补间动画、，要求每段间隔500ms,动画完成后View必须返回开始的位置，尽量使用更多的不同转换属性和插值器

## 安卓基础知识

安卓四大组件：Activity、Service、BroadCast Receiver、Content provider

### Activity

Activity是app与用户交互的入口，表示应用中的一个屏幕

###### mainfest清单文件

###### Activity的声明

```xml
<manifest ... >
      <application ... >
          <activity 
                android:name=".ExampleActivity" 
                android:label="ExampleActivity"/>
          ...
      </application ... >
      ...
    </manifest >
```

通过Intent filter可以设置Activity的的功能

```xml
<activity android:name=".ExampleActivity" android:icon="@drawable/app_icon">
    <intent-filter>
        <action android:name="android.intent.action.SEND" />
        <category android:name="android.intent.category.DEFAULT" />
        <data android:mimeType="text/plain" />
    </intent-filter>
</activity>
```

在此示例中，<action> 元素指定该 Activity 会发送数据。将 <category> 元素声明为 DEFAULT 可使 Activity 能够接收启动请求。<data> 元素指定此 Activity 可以发送的数据类型。

如何调用

```java
// Create the text message with a string
Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.setType("text/plain");
sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);
// Start the activity
startActivity(sendIntent);
```

声明应用权限

```xml
<manifest>
<activity android:name="...."
	android:permission=”com.google.socialapp.permission.SHARE_POST”
/>
```

声明用户权限

```xml
<manifest>
   <uses-permission android:name="com.google.socialapp.permission.SHARE_POST" />
</manifest>
```

###### 生命周期

下图为Activity 生命周期的简化图示

<img src="C:/Users/80303888/Desktop/android_java-master/android/pics/activity_lifecycle.png" width ="70%" alt = "activity_lifecycle"/>

- onCreate()`在系统首次创建 Activity触发 。在 Activity 的整个生命周期中只应发生一次。初始化 Activity 的基本组件,例如创建试图并将数据绑定到列表中。在此调用`setContentView()`定义 Activity 界面的布局。此方法会接收 `savedInstanceState` 参数（包含 Activity 先前保存状态的 `Bundle` 对象）。如果 Activity 此前未曾存在，`Bundle` 对象的值为 null。

- `onStart()`Activity 用来做进入前台与用户进行互动之前的最后准备工作。

- `onResume`捕获所有用户输入，应用的大部分核心功能都是在 `onResume()` 方法中实现的，后面总是跟着 `onPause()` 回调。
- `onPause()`表示用户暂时离开了该Activity，为用户离开activity的第一个标志。*可以使用 [`onPause()`](https://developer.android.com/reference/android/app/Activity?hl=zh-cn#onPause()) 方法释放系统资源、传感器（例如 GPS）手柄，或当您的 Activity 暂停且用户不需要它们时仍然可能影响电池续航时间的任何资源。*
- `onStop()` Activity 被销毁，新的 Activity 启动，或者现有的 Activity 正在进入“已恢复”状态并覆盖了已停止的 Activity。停止的 Activity 都将完全不再可见。
- `onRestart()` Activity 停止时的状态恢复 Activity。
- `onDestroy()`销毁 Activity 之前调用此回调。由于配置变更（例如设备旋转或多窗口模式），系统暂时销毁 Activity

oncreate方法实例

```java
TextView textView;

// some transient state for the activity instance
String gameState;

@Override
public void onCreate(Bundle savedInstanceState) {
    // call the super class onCreate to complete the creation of activity like
    // the view hierarchy
    super.onCreate(savedInstanceState);//重要语句，调用父类的

    // recovering the instance state
    if (savedInstanceState != null) {
        gameState = savedInstanceState.getString(GAME_STATE_KEY);
    }

    // set the user interface layout for this activity
    // the layout file is defined in the project res/layout/main_activity.xml file
    setContentView(R.layout.main_activity);//重要绑定视图

    // initialize member TextView so we can manipulate it later
    textView = (TextView) findViewById(R.id.text_view);//找到mainactivity中id为text_view的组件
}

// This callback is called only when there is a saved instance that is previously saved by using
// onSaveInstanceState(). We restore some state in onCreate(), while we can optionally restore
// other state here, possibly usable after onStart() has completed.
// The savedInstanceState Bundle is same as the one used in onCreate().
@Override
public void onRestoreInstanceState(Bundle savedInstanceState) {
    textView.setText(savedInstanceState.getString(TEXT_VIEW_KEY));
}

// invoked when the activity may be temporarily destroyed, save the instance state here
@Override
public void onSaveInstanceState(Bundle outState) {
    outState.putString(GAME_STATE_KEY, gameState);
    outState.putString(TEXT_VIEW_KEY, textView.getText());

    // call superclass to save any view hierarchy
    super.onSaveInstanceState(outState);
}
```

生命周期感知型组件`onResume`事件处理

```java
public class CameraComponent implements LifecycleObserver {

    ...

    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    public void initializeCamera() {
        if (camera == null) {
            getCamera();
        }
    }

    ...
}
```

生命周期感知型组件`onPause`事件处理

```java
public class JavaCameraComponent implements LifecycleObserver {

    ...

    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    public void releaseCamera() {
        if (camera != null) {
            camera.release();
            camera = null;
        }
    }

    ...
}
```

`onStop()`方法实例

```java
@Override
protected void onStop() {
    // call the superclass method first
    super.onStop();//重要
    //也可以做一些其他的事情

    );
}
```

进程生命周期和 Activity 状态之间的关系

| 系统终止进程的可能性 | 进程状态                   | Activity 状态        |
| :------------------- | :------------------------- | :------------------- |
| 较小                 | 前台（拥有或即将获得焦点） | 已创建 已开始 已恢复 |
| 较大                 | 后台（失去焦点）           | 已暂停               |
| 最大                 | 后台（不可见）             | 已停止               |
| 空                   | 已销毁                     |                      |

###### 从一个Activity启动另外一个Activity

可以使用 `startActivity()` 或 `startActivityForResult()` 方法启动新 Activity。这两种方法都需要传入一个 `Intent` 对象。

```java
//如何启动一个名为 SignInActivity 的 Activity
Intent intent = new Intent(this, SignInActivity.class);
startActivity(intent);
/*EXTRA_EMAIL extra 是一个字符串数组,包含电子邮件的收件人电子邮件地址。
*电子邮件应用响应此 intent 时，该应用会读取 extra 中提供的字符串数组
*并将该数组放入电子邮件撰写表单的“收件人”字段。在这种情况下，电子邮件应用
%=*的 Activity 会启动，并且当用户完成操作时，您的 Activity 会继续运行。
*/
Intent intent = new Intent(Intent.ACTION_SEND);
intent.putExtra(Intent.EXTRA_EMAIL, recipientArray);
startActivity(intent);
```

```java
//OnActivityResult方法
public class MyActivity extends Activity {
     // ...

     static final int PICK_CONTACT_REQUEST = 0;

     public boolean onKeyDown(int keyCode, KeyEvent event) {
         if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
             // When the user center presses, let them pick a contact.
             startActivityForResult(
                 new Intent(Intent.ACTION_PICK,
                 new Uri("content://contacts")),
                 PICK_CONTACT_REQUEST);
            return true;
         }
         return false;
     }

     protected void onActivityResult(int requestCode, int resultCode,
             Intent data) {
         if (requestCode == PICK_CONTACT_REQUEST) {
             if (resultCode == RESULT_OK) {
                 // A contact was picked.  Here we will just display it
                 // to the user.
                 startActivity(new Intent(Intent.ACTION_VIEW, data));
             }
         }
     }
 }
```

当两个 Activity 在同一个进程（应用）中，并且其中一个要启动另一个时。以下是 Activity A 启动 Activity B 时的操作发生顺序：

1. Activity A 的 `onPause()` 方法执行。
2. Activity B 的 `onCreate()`、`onStart()` 和 `onResume()` 方法依次执行（Activity B 现在具有用户焦点）。
3. 然后，如果 Activity A 在屏幕上不再显示，其 `onStop()` 方法执行。

###### Activity状态更改

**配置更改**

当配置发生更改时，Activity 会被销毁并重新创建。原始 Activity 实例将触发 [`onPause()`](https://developer.android.com/reference/android/app/Activity?hl=zh-cn#onpause)、[`onStop()`](https://developer.android.com/reference/android/app/Activity?hl=zh-cn#onstop) 和 [`onDestroy()`](https://developer.android.com/reference/android/app/Activity?hl=zh-cn#ondestroy) 回调。系统将创建新的 Activity 实例，并触发 [`onCreate()`](https://developer.android.com/reference/android/app/Activity?hl=zh-cn#onCreate(android.os.Bundle))、[`onStart()`](https://developer.android.com/reference/android/app/Activity?hl=zh-cn#onstart) 和 [`onResume()`](https://developer.android.com/reference/android/app/Activity?hl=zh-cn#onResume()) 回调。

**多窗口模式**

当用户从应用 A 切换到应用 B 时，系统会对应用 A 调用 `onPause()`，对应用 B 调用 `onResume()`。每当用户在应用之间切换时，系统就会在这两种方法之间切换。

###### Activity 或对话框显示在前台

当被覆盖的 Activity 的同一实例返回到前台时，系统会对该 Activity 调用 `onRestart()`、`onStart()` 和 `onResume()`。如果被覆盖的 Activity 的新实例进入后台，则系统不会调用 onRestart()，而只会调用 `onStart()` 和 `onResume()`。

**用户点按“返回”按钮**

如果 Activity 位于前台，并且用户点按了**返回**按钮，Activity 将依次经历 `onPause()`、`onStop()` 和 `onDestroy()` 回调。活动不仅会被销毁，还会从返回堆栈中移除。

###### 定义启动模式

两种方式定义Activity的新实例于当前任务关联，分别是和Inten标记。

mainfest清单文件

`launchMode`->`standard`、`singleTop`、`singleTask`、`singleInstance`

Intent标记

`FLAG_ACTIVITY_NEW_TASK`、`FLAG_ACTIVITY_SINGLE_TOP`、`FLAG_ACTIVITY_CLEAR_TOP`

Android中的进程包括

- 前台进程：正在用户的互动屏幕上运行一个 Activity（其 onResume() 方法已被调用）。

  ```markdown
  它有一个 BroadcastReceiver 目前正在运行（其 BroadcastReceiver.onReceive() 方法正在执行）。
  它有一个 Service 目前正在执行其某个回调（Service.onCreate()、Service.onStart() 或 Service.onDestroy()）中的代码。
  ```

- 可见进程:正在进行用户当前知晓的任务。

```markdown
它正在运行的 `Activity` 在屏幕上对用户可见，但不在前台（其 `onPause()` 方法已被调用）。举例来说，如果前台 Activity 显示为一个对话框，而这个对话框允许在其后面看到上一个 Activity，则可能会出现这种情况。
它有一个 `Service` 正在通过 `Service.startForeground()`（要求系统将该服务视为用户知晓或基本上对用户可见的服务）作为前台服务运行。
系统正在使用其托管的服务实现用户知晓的特定功能，例如动态壁纸、输入法服务等。
```

- 服务进程:包含一个已使用 `startService()` 方法启动的 `Service`
- 缓存进程:是目前不需要的进程

#### Fragment

 Activity 的模块化组成部分，它具有自己的生命周期，能接收自己的输入事件，并且您可以在 Activity 运行时添加或移除片段.片段必须始终托管在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响。

###### 生命周期方法

<img src="C:/Users/80303888/Desktop/android_java-master/android/pics/fragment_lifecycle.png" width ="30%" alt ="fragment_lifecycle"/>

回调方法与Activity类似，`onCreate`、`onStart()`、`onPause`  、`onStop()`

必须要实现的生命周期方法：

- `onCreate()`方法，系统会在创建片段时调用此方法。

- `onCreateView()`系统会在片段首次绘制其界面时调用此方法。如要为您的片段绘制界面，您从此方法中返回的 `View` 必须是片段布局的根视图。如果片段未提供界面，您可以返回 null。
- `onPause()`系统会将此方法作为用户离开片段的第一个信号

向Fragment添加界面

```java
//从 example_fragment.xml 文件加载布局
public static class ExampleFragment extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.example_fragment, container, false);
    }//布局资源ID，狂战布局父项的ViewGroup,指示是否应在扩展期间将扩展布局附加至 ViewGroup
}
```

向Activity添加片段

- 在Activity的布局文件中指定。

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <fragment android:name="com.example.news.ArticleListFragment"
            android:id="@+id/list"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />
    <fragment android:name="com.example.news.ArticleReaderFragment"
            android:id="@+id/viewer"
            android:layout_weight="2"
            android:layout_width="0dp"
            android:layout_height="match_parent" />
</LinearLayout>
```

- 通过编程方式

- ```java
  FragmentManager fragmentManager = getSupportFragmentManager();
  FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
  
  ExampleFragment fragment = new ExampleFragment();
  fragmentTransaction.add(R.id.fragment_container, fragment);
  fragmentTransaction.commit();
  ```

Fragment与Actvity的通信

```java
View listView = getActivity().findViewById(R.id.list);
```

片段三种存在状态

- 已恢复：片段在运行中的 Activity 中可见
- 已暂停：另一个 Activity 位于前台并具有焦点，但此片段所在的 Activity 仍然可见（前台 Activity 部分透明，或未覆盖整个屏幕）。
- 已停止：片段不可见。

也可使用 [onSaveInstanceState(Bundle)](https://developer.android.com/reference/androidx/fragment/app/Fragment?hl=zh-cn#onSaveInstanceState(android.os.Bundle))、[ViewModel](https://developer.android.com/reference/androidx/lifecycle/ViewModel?hl=zh-cn) 和持久化本地存储的组合，在配置变更和进程终止后保留片段的界面状态。

除此之外，为了处理和Activity的交互，定义了额外的回调方法

- `onAttach()`:在片段已与 Activity 关联时进行调用（`Activity` 传递到此方法内）
- `onCreateView()` 创建与片段关联的视图层。
- onActivityCreated()当 Activity 的 `onCreate()` 方法已返回时进行调用。
- `onDestroyView()` 移除与片段关联的视图层
- `onDetach()`取消片段与 Activity 的关联

<img src="C:/Users/80303888/Desktop/android_java-master/android/pics/activity_fragment_lifecycle.png" width="60%" alt = "activity_fragment_lifecycle"/>

默认情况下，Activity 停止时会被放入由系统管理的 Activity 返回栈中（以便用户通过*返回*按钮回退到 Activity，详细介绍请参阅[任务和返回栈](https://developer.android.com/guide/components/tasks-and-back-stack?hl=zh-cn)）。不过，只有当您在移除片段的事务执行期间通过调用 `addToBackStack()` 显式请求保存实例时，系统才会将片段放入由宿主 Activity 管理的返回栈。

###### 创建Fragment

```java
public class ArticleFragment extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.article_view, container, false);
    }
}
```

Fragment的通信

父级片段->子级片段

```java
/如需将数据从 Fragment B 传回到 Fragment A，
*请先在接收结果的 Fragment A 上设置结果监听器。
*在 Fragment A 的 FragmentManager 上调用 
*setFragmentResultListener() API
*/@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getParentFragmentManager().setFragmentResultListener("key", this, new FragmentResultListener() {
        @Override
        public void onFragmentResult(@NonNull String key, @NonNull Bundle bundle) {
            // We use a String here, but any type that can be put in a Bundle is supported
            String result = bundle.getString("bundleKey");
            // Do something with the result...
        }
    });
}
//在生成结果的 Fragment B 中，
//您必须使用相同的 requestKey 
//在同一 FragmentManager 上设置结果。
button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        Bundle result = new Bundle();
        result.putString("bundleKey", "result");
        getParentFragmentManager().setFragmentResult("requestKey", result);
    }
});
```

子级片段->父级片段

```kotlin
@Test
fun testFragmentResultListener() {
    val scenario = launchFragmentInContainer<ResultListenerFragment>()
    scenario.onFragment { fragment ->
        val expectedResult = "result"
        fragment.parentFragmentManagager.setResult("requestKey", bundleOf("bundleKey" to expectedResult))
        assertThat(fragment.result).isEqualTo(expectedResult)
    }
}

class ResultListenerFragment : Fragment() {
    var result : String? = null
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Use the Kotlin extension in the fragment-ktx artifact
        setResultListener("requestKey") { key, bundle ->
            result = bundle.getString("bundleKey")
        }
    }
}
```

其他Fragemen通信（两个 Fragment 绝不能直接通信）

```java
//fragment->activity
public class HeadlinesFragment extends ListFragment {
    OnHeadlineSelectedListener callback;

    public void setOnHeadlineSelectedListener(OnHeadlineSelectedListener callback) {
        this.callback = callback;
    }

    // This interface can be implemented by the Activity, parent Fragment,
    // or a separate test implementation.
    public interface OnHeadlineSelectedListener {
        public void onArticleSelected(int position);
    }

    // ...
}
//mainactivty
public static class MainActivity extends Activity
    implements HeadlinesFragment.OnHeadlineSelectedListener{
    // ...

    @Override
    public void onAttachFragment(Fragment fragment) {
        if (fragment instanceof HeadlinesFragment) {
            HeadlinesFragment headlinesFragment = (HeadlinesFragment) fragment;
            headlinesFragment.setOnHeadlineSelectedListener(this);
        }
    }
}
//托管 Activity 可通过使用 findFragmentById() 捕获 Fragment 实例，将消息传递到 Fragment，然后直接调用 Fragment 的公共方法。
public static class MainActivity extends Activity
    implements HeadlinesFragment.OnHeadlineSelectedListener{
    ...

        public void onArticleSelected(int position) {
        // The user selected the headline of an article from the HeadlinesFragment
        // Do something here to display that article

        ArticleFragment articleFrag = (ArticleFragment)
            getSupportFragmentManager().findFragmentById(R.id.article_fragment);

        if (articleFrag != null) {
            // If article frag is available, we're in two-pane layout...

            // Call a method in the ArticleFragment to update its content
            articleFrag.updateArticleView(position);
        } else {
            // Otherwise, we're in the one-pane layout and must swap frags...

            // Create fragment and give it an argument for the selected article
            ArticleFragment newFragment = new ArticleFragment();
            Bundle args = new Bundle();
            args.putInt(ArticleFragment.ARG_POSITION, position);
            newFragment.setArguments(args);

            FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();

            // Replace whatever is in the fragment_container view with this fragment,
            // and add the transaction to the back stack so the user can navigate back
            transaction.replace(R.id.fragment_container, newFragment);
            transaction.addToBackStack(null);

            // Commit the transaction
            transaction.commit();
        }
    }
}
```



###### Safe Args

首先在顶级build.gradle添加依赖，在应用build文件添加依赖

Safe Args 会生成一个 `SpecifyAmountFragmentDirections` 类，其中只包含一个 `actionSpecifyAmountFragmentToConfirmationFragment()` 方法（该方法会返回 `NavDirections` 对象）。然后，您可以将返回的 `NavDirections` 对象直接传递到 `navigate()`

```java
发送方
@Override
public void onClick(View view) {
   EditText amountTv = (EditText) getView().findViewById(R.id.editTextAmount);
   int amount = Integer.parseInt(amountTv.getText().toString());
   ConfirmationAction action =
           SpecifyAmountFragmentDirections.confirmationAction()
   action.setAmount(amount)
   Navigation.findNavController(view).navigate(action);
}
//接收方
@Override
public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
    TextView tv = view.findViewById(R.id.textViewAmount);
    int amount = ConfirmationFragmentArgs.fromBundle(getArguments()).getAmount();
    tv.setText(amount + "")
}
```

使用bundle对象在目的地之间传参

```java
发送方
Bundle bundle = new Bundle();
bundle.putString("amount", amount);
Navigation.findNavController(view).navigate(R.id.confirmationAction, bundle);
//接收方
TextView tv = view.findViewById(R.id.textViewAmount);
tv.setText(getArguments().getString("amount"));
```

ViewPager 和ViewPager2创建包含标签页的滑动视图

### intent 

Intent是一个消息传递对象。

Intent 过滤器 

### 架构组件

https://www.cnblogs.com/Android-Alvin/

https://github.com/googlecodelabs/

[应用架构指南](https://developer.android.com/jetpack/docs/guide?hl=zh-cn)

<img src="C:/Users/80303888/Desktop/gukkidocs/hiandroid/pics/final-architecture.png" alt="final-architecture" style="zoom:50%;" />

应用启动组件

DataStore

视图绑定

```java
与findViewById区别
```

数据绑定库

生命周期-Lifecycle

[`Lifecycle`](https://developer.android.com/reference/androidx/lifecycle/Lifecycle?hl=zh-cn) 是一个类，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。

```
notes-架构的目的之一分离关注点-高聚合，低耦合
```

LiveData(观察者模式)

Room

ViewModel

往上给view层数据，往下从model层获取数据，并不直接产生数据

WorkManager

```java
notes：不要在主线程做耗时操作，例如IO，网络请求
```

#### 重点

```java
app架构指南
组件生命周期，LifeCycle-aware组件
数据持久化，LiveData, Room, 
异步任务，workManager
```

#### 难点

```java
理解组件生命周期
了解数据持久化相关类使用场景
了解异步任务
```

#### 预习问题

##### 1、MVVM架构是什么？

###### 概念

Model-View-ViewModel的简称，MVVM模式将应用分为三层：Model层主要负责数据的提供，View层主要负责界面的显示，ViewModel层主要负责业务逻辑的处理。各个层职责单一，结构清晰，应用可以很方便地进行测试、维护和扩展。

<img src="C:/Users/80303888/Desktop/gukkidocs/hiandroid/pics/mvvm.png" alt="mvvm" style="zoom:50%;" />

- **Model层**：数据层，主要负责数据的提供。Model层提供业务逻辑的数据结构（比如，实体类），提供数据的获取（比如，从本地数据库或者远程网络获取数据），提供数据的存储。
- **View层**：UI层，主要负责界面的显示。View层不涉及任何的业务逻辑处理，它持有ViewModel层的引用，当需要进行业务逻辑处理时通知ViewModel层。
- ViewModel层，主要负责业务逻辑的处理。ViewModel层不涉及任何的视图操作。通过官方提供的Data Binding库，View层和ViewModel层中的数据可以实现绑定，ViewModel层中数据的变化可以自动通知View层进行更新，因此ViewModel层不需要持有View层的引用。ViewModel层可以看作是View层的数据模型和Presenter层的结合。
  https://blog.csdn.net/u012317510/article/details/80247756

###### 其他架构

<img src="C:/Users/80303888/Desktop/gukkidocs/hiandroid/pics/mvc_mvp.png" alt="mvc_mvp.png" style="zoom:33%;" />

MVC

- View：布局的xml文件，或者纯Java写的布局，可以把页面显示的逻辑直接放在View中。
- Model：数据处理层，可以直接和View进行交互。
- Controller：把特定的功能逻辑抽离出来，作为控制层，保证View层和Model层的功能单一性，便于维护。

MVP

- View：Activity：作为显示层。
- Presenter：逻辑层，从Activity中抽离出功能逻辑，简化Activity的代码。
- Model：数据处理层，主要负责网络请求，本地数据加载等操作，进一步简化Activity的代码。

https://blog.csdn.net/u011315960/article/details/82869206

######  对比

##### 2、架构组件的使用场景

架构组件LiveData, Room, ViewModel, Paging, Navigation 使用场景

###### LiveData

设计模式-(观察者模式)

https://blog.csdn.net/gdutxiaoxu/article/details/86660760

[`LiveData`](https://developer.android.google.cn/reference/androidx/lifecycle/LiveData) 是`一种可观察的数据存储器类`，它可以感知 Activity、Fragment或Service 等组件的生命周期。

- 它可以做到在组件处于激活状态的时候才会回调相应的方法，从而刷新相应的 UI。
- 当担心发生内存泄漏的时候
- 当 config 导致 activity 重新创建的时候，不需要手动取处理数据的储存和恢复。它已经帮我们封装好了。
- 当 Actiivty 不是处于激活状态的时候，如果你想 livedata setValue 之后立即回调 obsever 的 onChange 方法，而不是等到 Activity 处于激活状态的时候才回调 obsever 的 onChange 方法，你可以使用 observeForever 方法，但是你必须在 onDestroy 的时候 removeObserver。
  使用场景：
  例如：回想一下，在你的项目中，是不是经常会碰到这样的问题，当网络请求结果回来的时候，你经常需要判断 Activity 或者 Fragment 是否已经 Destroy， 如果不是 destroy，才更新 UI。而当你如果使用 Livedata 的话，因为它是在 Activity 处于 onStart 或者 onResume 的状态时，他才会进行相应的回调，因而可以很好得处理这个问题，不必写一大堆的 activity.isDestroyed()

###### Room

https://www.jianshu.com/p/654d883e6ed0

Room是Google推出的Android架构组件库中的数据持久化组件库, 也可以说是在SQLite上实现的一套ORM解决方案。Room主要包含三个部分：

- **Database** : 持有DB和DAO
- **Entity** : 定义POJO类，即数据表结构
- **DAO**(Data Access Objects) : 定义访问数据（增删改查）的接口

<img src="C:/Users/80303888/Desktop/gukkidocs/hiandroid/pics/room.png" alt="room" style="zoom:50%;" />

在SQLite API方式实现数据持久化的项目中，相信都有一个任务繁重的`SQLiteOpenHelper`实现, 一堆维护表的字段的`Constant`类， 一堆代码类似的数据库访问类（DAO），访问数据库时需要做Cursor的遍历，构建并返回对应的POJO类...相比之下，Room作为在SQLite之上封装的ORM库确实有诸多优势。

- 比SQLite API更简单的使用方式
- 省略了许多重复代码
- 能在编译时校验sql语句的正确性
- 数据库相关的代码分为Entity, DAO, Database三个部分，结构清晰
- 简单安全的数据库升级方案

###### ViewModel

是负责准备和管理和UI组件(Fragment/Activity)相关的数据类，也就是说ViewModel是用来管理UI相关的数据的，同时ViewModel还可以用来负责UI组件间的通信。ViewModel用来存储和管理UI相关的数据，可于将一个Activity或Fragment组件相关的数据逻辑抽象出来，并能适配组件的生命周期，如当屏幕旋转Activity重建后，ViewModel中的数据依然有效。

通常Android系统来管理UI controllers（如Activity、Fragment）的生命周期，由系统响应用户交互或者重建组件，用户无法操控。当组件被销毁并重建后，原来组件相关的数据也会丢失，如果数据类型比较简单，同时数据量也不大，可以通过onSaveInstanceState()存储数据，组件重建之后通过onCreate()，从中读取Bundle恢复数据。但如果是大量数据，不方便序列化及反序列化，则上述方法将不适用。
UI controllers经常会发送很多异步请求，有可能会出现UI组件已销毁，而请求还未返回的情况，因此UI controllers需要做额外的工作以防止内存泄露。
当Activity因为配置变化而销毁重建时，一般数据会重新请求，其实这是一种浪费，最好就是能够保留上次的数据。
UI controllers其实只需要负责展示UI数据、响应用户交互和系统交互即可。但往往开发者会在Activity或Fragment中写许多数据请求和处理的工作，造成UI controllers类代码膨胀，也会导致单元测试难以进行。我们应该遵循职责分离原则，将数据相关的事情从UI controllers中分离出来。

- ViewModel职责是为Activity或Fragment管理、请求数据，具体数据请求逻辑不应该写在ViewModel中，否则ViewModel的职责会变得太重，此处- 需要一个引入一个Repository，负责数据请求相关工作。具体请参考 Android架构组件。

- ViewModel可以用于Activity内不同Fragment的交互，也可以用作Fragment之间一种解耦方式。
- ViewModel也可以负责处理部分Activity/Fragment与应用其他模块的交互。
- ViewModel生命周期（以Activity为例）起始于Activity第一次onCreate()，结束于Activity最终finish时。

https://www.cnblogs.com/Android-Alvin/p/12109378.html

###### Paging

分页技术，Paging的主要功能就是一次加载小部分数据，可以减少网络带宽和系统资源的使用

###### Navigation

Google 在2018年推出了的Android Jetpack里的一种管理fragment的架构模式`navigation`. 字面意思是导航,但是除了做APP引导页面以外.也可以使用在App主页分tab的情况，甚至可以一个功能模块就一个activity大部分页面UI都使用fragment来实现,而navigation就成了管理fragment至关重要的架构。但是,它不单单只能管理fragment也可以管理activity。

##### 3、WorkManager

执行异步任务的优势是什么

WorkManager是google提供的异步执行任务的管理框架，会根据手机的API版本和应用程序的状态来选择适当的方式执行任务。当应用在运行的时候会在应用的进程中开一条线程来执行任务，当退出应用时，WorkManager会选择根据设备的API版本使用适合的算法调用JobScheduler或者Firebase JobDispatcher,或者AlarmManager来执行任务。

<center class="half">
<img src="pics/workmanager1.png" width = "50%" height = "100%" alt="workmanager1" align=left />
<img src="pics/workmanager2.png" width = "50%" height = "30%"  alt="workmanager2" align=right />
<center>



使用 WorkManager 实现可延期、可靠的工作，WorkManager 适用于**可延期**工作，即不需要立即运行但需要**可靠运行**的工作，即使用户退出或设备重启也不受影响。例如：

- 向后端服务发送日志或分析数据
- 定期将应用数据与服务器同步

WorkManager 不适用于应用进程结束时能够安全终止的运行中后台工作，也不适用于需要立即执行的工作。

**在应用程序‘死了’的时候可以继续运行。**
https://www.cnblogs.com/Android-Alvin/p/12109545.html
小作业：尝试使用架构组件编写app

### 导航组件

概念

- 导航图：在一个集中位置包含所有导航相关信息的 XML 资源。这包括应用内所有单个内容区域（称为*目标*）以及用户可以通过应用获取的可能路径。
- `NavHost`：显示导航图中目标的空白容器。导航组件包含一个默认 `NavHost` 实现 ([`NavHostFragment`](https://developer.android.com/reference/androidx/navigation/fragment/NavHostFragment?hl=zh-cn))，可显示 Fragment 目标。
- `NavController`：在 `NavHost` 中管理应用导航的对象。当用户在整个应用中移动时，`NavController` 会安排 `NavHost` 中目标内容的交换
  在应用中导航时，您告诉 `NavController`，您想沿导航图中的特定路径导航至特定目标，或直接导航至特定目标。`NavController` 便会在 `NavHost` 中显示相应目标。

导航图是一种资源文件，其中包含您的所有目的地和操作。该图表会显示应用的所有导航路径。

#### 重点

导航组件使用场景
导航图设计
目标间传递数据，添加动画
以编程方式与导航组件交互

#### 难点

导航组件原理
设计导航图并在应用中使用

#### 预习问题

导航图存储位置
如何确保传递数据类型安全
NavController和NavHost的关系

作业：

- 利用Navigation Editor完成一个单Activity,多Fragment的导航图
- 为两个fragment间添加过渡动画
- 利用safe args传递数据

### 界面

#### 重难点

##### 重点

常见布局特性以及使用方法
RecycleView的使用
如何添加通知
控制系统界面

##### 难点

布局界面分析
常用控件使用方法
FragmentLayout,LinearLyout,RelativeLyout.ConstraintLayout
RecycleView,Dialog

#### 预习与作业

##### 预习问题

简单解释下LinearLyout和RelativeLyout的区别
怎么更新RecycleView的数据
Dialog关闭方法Dismiss和cancel的区别

##### 作业

利用constraintlayout构建一个登陆界面，至少包括用户名，密码输入

利用recyclerview搭建一个可滚动的列表，item需要包括文字和图片

启动一个前台服务并发送通知

#### 布局

布局定义了应用中的界面结构，布局的所有元素均使用View和ViewGroup对象的层次结构进行构建。`View` 通常绘制用户可查看并进行交互的内容。然而，`ViewGroup` 是不可见容器，用于定义 `View` 和其他 `ViewGroup` 对象的布局结构。

<img src="C:/Users/80303888/Desktop/gukkidocs/hiandroid/pics/viewgroup.png" alt="img" style="zoom: 33%;" />

布局的声明方式：**在 XML 中声明界面元素**。**在运行时实例化布局元素**。

布局文件声明布局后,以xml文件的形式保存在layout目录中

### 动画与过渡

作业：选择不同插值器，基于多个常见属性做动画，用一个界面展示出来。

测试弹性动画中不同参数对动画的影响，用一个界面展示

作业1和作业2使用ViewPager2展示，并为其添加动画。

属性动画(animator)

使用Animator在设定的时间段内修改对象的属性值来创建动画

视图动画(anim)

补间动画:使用Animation对单张图片执行一系列转换来创建动画

和帧动画：使用AnimationDrawable按顺序显示一系列图片来创建动画

### 图片与图形

用一个demo展示Drawable类型

使用DEMO分析不同基本的硬件加速控制

选择一个界面(自己的demo或者oppo内置的APP或第三方APP)进行渲染性能分析

实例化Drawable的方法：

- 扩充保存在项目中的图片资源

- 扩充用于定义可绘制属性的XML资源

通过资源对象创建可绘制对象

安卓支持的图片类型为PNG(首选)、JPG(可适用)、GIf(不推荐)、Webp

矢量可绘制对象

bitmap

[NinePatchDrawable](https://developer.android.google.cn/reference/android/graphics/drawable/NinePatchDrawable) 图形是一种可拉伸的位图，可用作视图的背景。Android 会自动调整图形的大小以适应视图的内容。

形状可绘制对象
通过XML资源创建可绘制对象
矢量图的优势：图片可缩放，同时不降低显示质量
四个级别控制硬件加速：分别是应用、Activity、窗口、视图
优化应用渲染性能的方式：

- 减少过度绘制
- 性能与视图层次结构
- 使用GPU渲染模式分析工具进行分析

### 用户数据和身份

#### 重难点

##### 重点

##### 难点

##### 掌握点

#### 预习和作业

##### 预习

- 生物验证对话框可以做哪些定制？

​       取消btn提示 使用屏幕锁定依据 PIN码 解锁图案或密码  

- 自动填充框架要有完整的功能需要手机中有哪些组成部分存在？

  自动填充服务：无需输入重复信息，减少用户的错误输入

  客户端：提供需要填充或保存用户数据的视图的应用

  安卓系统：定义工作流程，是服务和客户端协同工作的基础架构

- google希望的唯一标识符用的时候符合什么原则

  **避免使用硬件标识符**。在大多数用例中，您可以避免使用硬件标识符，例如 SSAID (Android ID)，而不会限制所需的功能。

  Android 10（API 级别 29）对不可重置的标识符（包括 IMEI 和序列号）添加了限制。您的应用必须是[设备或个人资料所有者应用](https://source.android.com/devices/tech/admin/managed-profiles?hl=zh-cn#device_administration)，具有[特殊运营商权限](https://source.android.com/devices/tech/config/uicc?hl=zh-cn)或具有 `READ_PRIVILEGED_PHONE_STATE` 特许权限，才能访问这些标识符。

  **只针对用户剖析或广告用例使用广告 ID**。在使用[广告 ID](https://developers.google.com/android/reference/com/google/android/gms/ads/identifier/AdvertisingIdClient?hl=zh-cn) 时，请始终[遵循用户关于广告跟踪的选择](https://play.google.com/about/monetization-ads/ads/ad-id/?hl=zh-cn)。此外，请确保标识符无法关联到个人身份信息 (PII)，并避免桥接广告 ID 重置。

  **尽一切可能针对防欺诈支付和电话以外的所有其他用例使用[实例 ID](https://firebase.google.com/docs/reference/android/com/google/firebase/iid/FirebaseInstanceId?hl=zh-cn) 或私密存储的 GUID**。对于绝大多数非广告用例，使用实例 ID 或 GUID 应已足够。

  **使用适合您的用例的 API 以尽量降低隐私权风险**。使用 [DRM API](http://source.android.com/devices/drm?hl=zh-cn) 保护重要内容，并使用 [SafetyNet API](https://developer.android.com/training/safetynet?hl=zh-cn) 防止滥用行为。SafetyNet API 是能够确定设备真伪而不会招致隐私权风险的最简单方法。

##### 作业

对string

#### 基础知识

身份验证类型

`BIOMETRIC_STRONG` 强强度，指纹

`BIOMETRIC_WEAK` 弱强度、人脸

`DEVICE_CREDENTIAL` 屏幕锁定依据、如PIN，解锁图案，密码



1. 问题1

**生物识别验证框定制，除了身份验证还可以做什么**

加密，





1. 


该框架支持以下加密对象：[`Signature`](https://developer.android.com/reference/java/security/Signature?hl=zh-cn)、[`Cipher`](https://developer.android.com/reference/javax/crypto/Cipher?hl=zh-cn) 和 [`Mac`](https://developer.android.com/reference/javax/crypto/Mac?hl=zh-cn)。

生物识别做一个字符串的

### 后台任务

#### 重难点

##### 重点

1. 后合任务的类别和推荐的实现方法！

2. 后台线程使用及和主线程通信方法
3. 广播使用和限制
4. 如何保持唤醒状态
5. 设置Alarm任务

##### 难点

1. 后台任务的英别和推荐的赛现方法
2. 相关API的实现原理

##### 掌握点

1. 学会使用ExecutorService. Handler、 JobScheduler、WakeLock和Alarm、WorkManager
2. 理解Android设计这些不同后台任务API的用途。
3. 了解Android对于后台任务的限制。理解背看的设计原因


#### 预习和课后

##### 预习问题

1. Service和线程的区别？

   service在主线程，想要去其他线程要用intentservice

2. 在BroodcostReceiver 如何处理耗的任务?

3. BoodcostReceiver里使用线程时需要注意什么问题？

##### 课后作业

1. 设计、编写并触发一个 即时任务、一个延期任务和一个精确任务。执行时间需要大于10s。
2. adb shell 查看Job、WakeLock和Alarm的方法。以实际操作的截图形式完成作业。
3. Handler.sendXX/postXX/removeXX等方法 是如何保证线程安全的？文字描述回答即可，如果有源码贴图更加。

adbshell

#### 基础知识 

相关知识: adb调试，多线程编程，ANR，进程优先级，功耗优化

后台任务类别：即时任务、延期任务、精确任务

<img src="C:/Users/80303888/Desktop/gukkidocs/hiandroid/pics/task1.png" width = "width" alt ="task1"/>



### 触摸和输入

事件监听器

- `onClick()` 在View.OnClickListener中，用户轻触项目(处于轻触模式)，或者使用导航键或轨迹球聚焦于项目，然后按适用的“Enter”键或按下轨迹球时，系统会调用此方法。
- `onLongClick()`

### 音频和视频

#### 重难点

##### 重点

1、常见的音频和视频格式以及编解码
2、媒体应用的架构
3、音频应用简介
4、视频应用简介

##### 难点

1、编码和解码的原理
2、媒体应用架构
3、音频服务端和客户端开发
4、音频服务端和客户端开发

##### 掌握知识点

1、基本的音频和视频格式
2 、编解码的原理
3、媒体应用的架构
4、带用的类以及服务端和客户端的互动

#### 预习和作业

##### 预习

1、常见的音频，图片，视频格式。为什么要编码和解码？
编码：压缩音视频信号中的无用信息和不重要信息，减小体积、便于存储、传输、交流。
解码：将编码过的内容还原为原始信号。

2、Activiy的生命周期和Service的生命周期分别是？

- onStartCommand()当另一个组件（如 Activity）请求启动服务时，系统会通过调用 startService() 来调用此方法。执行此方法时，服务即会启动并可在后台无限期运行。如果您实现此方法，则在服务工作完成后，您需负责通过调用 stopSelf() 或 stopService() 来停止服务。（如果您只想提供绑定，则无需实现此方法。）
- onBind()当另一个组件想要与服务绑定（例如执行 RPC）时，系统会通过调用 bindService() 来调用此方法。在此方法的实现中，您必须通过返回 IBinder 提供一个接口，以供客户端用来与服务进行通信。请务必实现此方法；但是，如果您并不希望允许绑定，则应返回 null。
- onCreate() 首次创建服务时，系统会（在调用 onStartCommand() 或 onBind() 之前）调用此方法来执行一次性设置程序。如果服务已在运行，则不会调用此方法。
- onDestroy() 当不再使用服务且准备将其销毁时，系统会调用此方法。服务应通过实现此方法来清理任何资源，如线程、注册的侦听器、接收器等。这是服务接收的最后一个调用。
  无论所有服务是通过 startService() 还是 bindService() 创建，系统均会为其调用onCreate() 和 onDestroy() 方法 。

3、媒体会话（和播放器通信）和媒体控制器（和界面U通信）的对应关系

![image-20201026152129671](C:/Users/80303888/Desktop/gukkidocs/Linux_Git_UML/pics/image-20201026152129671.png)

- 媒体会话 负责与播放器的所有通信，对应用的其他部分隐藏播放器的API。系统只能从控制播放器的媒体会话中调用播放器。
  会话会维护播放器状态（播放/暂停）的表示形式以及播放内容的相关信息。会话可以接收来自一个或多个媒体控制器的回调。这样，应用的界面以及运行 Wear OS 和 Android Auto 的配套设备便可以控制您的播放器。响应回调的逻辑必须保持一致。无论哪个客户端应用发起了回调，对 MediaSession 回调的响应都应该相同。
- 媒体控制器 隔离您的界面。您的界面代码只与媒体控制器（而非播放器本身）通信。媒体控制器会将传输控制操作转换为对媒体会话的回调。每当会话状态发生变化时，它也会接收来自媒体会话的回调。这提供了一种自动更新关联界面的机制。媒体控制器一次只能连接到一个媒体会话。
  当您使用媒体控制器和媒体会话时，您可以在运行时部署不同的接口和/或播放器。您可以根据运行应用的设备的功能单独更改该应用的外观和/或性能。



##### 课后作业

画出媒体会话和媒体控制器，以及他们与通信的UI界面和播放器的架构图

#### 基础知识

常见的支持的媒体格式

音频：`AAC LC`  `HE-AACv1`  `HE-AACv2` `AAC ELD`  `AMR-NB` `AMR-WB` `FLAC` `GSM` `MIDI` `MP3` `Opus` `PCM/WAVE` `Vorbis`

视频：`H.263` `H.264 AVC BP` `H.264 AVC MP` `H.265 HEVC` `MPEG-4 SP` `VP8` `VP9`

图片：`BMP` `GIF` `JPEG` `PNG` `WebP` `HEIF`

音视频播放支持的网络协议：`RTSP(RTP、SDP)` `HTTP\HTTPS渐进式流式传输` `HTTP\HTTPS实时流式传输`

note: android 3.1之前不支持HTTPS协议

手机画质

| 标清低画质： |  176*144px  |
| :----------: | :---------: |
|  标清高画质  |  480*360px  |
|   高清720p   | 1280*720px  |
|  高清1080p   | 1920*1080px |
|    超高清    | 3840*2160px |

 对于VP9 VP8 H.264和H.265编解码器。设备必须支持通过标准Android api在同一视频内实时进行动态视频分辨率和帧速率的切换，并且能够只是设备上每个编解码器所支持的最大分辨率。

*杜比视界*

通过HTTP和RTSP流式传输的视频内容，对于3GPP和MPEG-4容器，moov atom必须放在mdat atom之前位于ftyp atom之后

对于SGPP MPEG-4和webM容器，对应于相同时间偏移量的音频和视频样本的偏差不能超过 500 KB。

媒体的编解码器

- [`isSoftwareOnly()`](https://developer.android.com/reference/android/media/MediaCodecInfo#isSoftwareOnly)

  如果编解码器仅在软件中运行，则返回 true。软件编解码器不保证渲染性能。

- [`isHardwareAccelerated()`](https://developer.android.com/reference/android/media/MediaCodecInfo#isHardwareAccelerated)

  如果编解码器由硬件加速，则返回 true。

- [`isVendor()`](https://developer.android.com/reference/android/media/MediaCodecInfo#isVendor)

  如果编解码器由设备供应商提供，则返回 true；如果由 Android 平台提供，则返回 false。

- [`isAlias()`](https://developer.android.com/reference/android/media/MediaCodecInfo#isAlias)

  `MediaCodecList` 可能包含使用备用编解码器名称（别名）的同一基础编解码器的其他条目。如果此条目中的编解码器是另一编解码器的别名，则此方法返回 true。

此外，[`MediaCodec.getCanonicalName()`](https://developer.android.com/reference/android/media/MediaCodecInfo#getCanonicalName) 返回通过别名创建的编解码器的基础编解码器名称

性能点

性能点表示编解码器以特点高度、宽度、帧率渲染视频的能力，UHD_60 表示60帧/超高清视频(3860*2160px)

媒体应用架构

播放器：播放音视频

界面：运行播放器并显示播放器状态，传输空间

UI和player的交互通过media session和media controller两个控件，通过使用与标准播放器操作（播放、暂停、停止等）相对应的预定义回调，以及用于定义应用独有的特殊行为的可扩展自定义调用。

media session(媒体会话) 负责与播放器的所有通信，系统只能从媒体会话中调用播放器。会话维护播放器的状态(播放/暂停)的表现形式以及播放内容，可以接受一个以上的多媒体控制器的回调。会话在不同客户端相应回调的逻辑应该一致。

media controller(媒体控制器)，隔离界面，UI代码只和媒体控制器通信，媒体控制器将传输控制操作转换为对于媒体会话的回调。当会话状态发生变化时，也接受来自媒体会话的回调。媒体控制器一次只能链接到一次媒体会话。

对于视频应用，通常用单个Activity实现，屏幕是activity的一部分。

对于音频应用，播放器可以作为后台任务运行，用户可以切换到其他应用。对界面使用activity，对于播放器使用服务。mediabrowser和mediabrowserservice.服务组件作为包含meida session以及meidaBrowserService子类，activity包含UI，media controller和media browser。mediaBrowser和mediaBrowserService通信。

用 `MediaBrowserService` 可以让配套设备（如 Android Auto 和 Wear）轻松发现您的应用，连接到该应用，浏览内容并控制播放，而根本无需访问应用的界面 Activity。事实上，可以有多个应用同时连接到同一个 `MediaBrowserService`，每个应用都有自己的 `MediaController`。提供 `MediaBrowserService` 的应用应该能够同时处理多个连接。



google建议实现类MediaSessionCompat和MediaControllerCompat

媒体会话的使用

在activity或者service的oncreate方法创建并初始化

### 应用数据和文件

#### 重难点

##### 重点

1、应用存储持久化数据的方法包括：文件、sharedPreference、数据库
2、应用间共享数据：Intent、ContentProvider、FileProvider


##### 难点

数据库创建方法

ContentProvider的使用

##### 掌握点

常用的数据持久化方法

通过使用Intent及ContentProvider在进程间进行数据共享

使用FileProvider在进程间共享文件数据

#### 预习和课后

##### 预习

1、文件、sharedPreference、数据库存储数据的异同
系统提供了以下几种保存应用数据的选项：
应用专属存储空间：存储仅供应用使用的文件，可以存储到内部存储卷中的专属目录或外部存储空间中的其他专属目录。使用内部存储空间中的目录保存其他应用不应访问的敏感信息。
共享存储：存储您的应用打算与其他应用共享的文件，包括媒体、文档和其他文件。
偏好设置：以键值对形式存储私有原始数据。
数据库：使用 Room 持久性库将结构化数据存储在专用数据库中。
2、Intent和ContentProvider进程间共享数据的主要使用场景分别是什么？
intent
在应用之间分享少量文本或数值数据，则应发送包含该数据的Intent。通过 intent 及其关联的 extra 让用户可以使用他们喜爱的应用快速轻松地分享信息
Contentprovider
您会在以下两种场景中使用内容提供程序：一种是通过实现代码访问其他应用中的现有内容提供程序；另一种是在应用中创建新的内容提供程序，从而与其他应用共享数据。
内容提供程序可精细控制数据访问权限。您可以选择仅在应用内限制对内容提供程序的访问，授予访问其他应用数据的权限，或配置读取和写入数据的不同权限。
您可以使用内容提供程序将细节抽象化，以用于访问应用中的不同数据源。例如，应用可能会在 SQLite 数据库中存储结构化记录，以及视频和音频文件。如果您在应用中实现此开发模式，则可使用内容提供程序访问所有这类数据。
3、进程间共享文件使用FileProvider相对于直接使用File的安全性体现在什么地方?
如需将应用中的文件提供给其他应用，唯一安全的做法就是向接收方应用发送文件的内容 URI，并授予对该 URI 的临时访问权限。具有临时 URI 访问权限的内容 URI 之所以安全，是因为它们仅供接收该 URI 的应用使用，并且会自动过期。Android FileProvider 组件提供了 getUriForFile() 方法，用于生成文件的内容 URI。

##### 课后

一、作业内容
编写两个apk，APK_A(com.test.apka), APK2_B(com.test.apkb)

1. APK_A 的Activity通过Intent拉起 APK_B的Activity， 并显示A通过Intent传输数据 Hello Android，
2. APK_B将A传过来的Hello Android 通过sharedPrefrence存储到本地， key值为 app_data
3. APK_A 的Activity通过FileProvider传输文件给APK_B的Service, APK_B将文件写到自己的私有目录下。

#### 基础知识

###### 安卓系统四种不同的数据存储方案：

- [内部文件存储](https://developer.android.google.cn/guide/topics/data/data-storage#filesInternal)：在设备文件系统中存储应用私有文件。
- [外部文件存储](https://developer.android.google.cn/guide/topics/data/data-storage#filesExternal)：在共享外部文件系统中存储文件。此方式通常用于共享的用户文件，如照片。
- [共享首选项](https://developer.android.google.cn/guide/topics/data/data-storage#pref)：在键值对中存储私有的原始数据。
- [数据库](https://developer.android.google.cn/guide/topics/data/data-storage#db)：在私有数据库中存储结构化数据。

如果与其他应用共享文件，则应使用 `FileProvider` API

如果向其他应用公开应用数据，则可使用 `ContentProvider`。借助内容提供程序，我们可以完全控制向其他应用提供哪些读取/写入访问权限，无论您为数据选择何种存储介质（尽管通常为数据库）

默认情况保存在内部存储的文件是应用私有文件，其他应用和用户不能访问(需要root)。对于用户希望保留的文件，不能使用内部存储(应用卸载时，内部存储的文件也会随之移除)，可以用`MediaStore API`

内部缓存文件保存在特殊缓存目录，有可能被删除

外部存储：SD卡等

对于想要保存的相对较小键值对集合，使用`SharedPreferences API`

`getSharedPreferences()`方法可以从`Contex`调用 

```java
Context context = getActivity();
    SharedPreferences sharedPref = context.getSharedPreferences(
            getString(R.string.preference_file_key), Context.MODE_PRIVATE);
```

```
SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);
 //只需要activity的一个共享偏好设置文件   
```

###### 使用intent分享简单的数据

```java
//发送简单文本
Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_TEXT, "This is my text to send.");
sendIntent.setType("text/plain");

Intent shareIntent = Intent.createChooser(sendIntent, null);
startActivity(shareIntent);
//发送二进制内容
Intent shareIntent = new Intent();
shareIntent.setAction(Intent.ACTION_SEND);
shareIntent.putExtra(Intent.EXTRA_STREAM, uriToImage);
shareIntent.setType("image/jpeg");
startActivity(Intent.createChooser(shareIntent, getResources().getText(R.string.send_to)));
//分享多分内容
ArrayList<Uri> imageUris = new ArrayList<Uri>();
imageUris.add(imageUri1); // Add your image URIs here
imageUris.add(imageUri2);

Intent shareIntent = new Intent();
shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);
    shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, imageUris);
shareIntent.setType("image/*");
startActivity(Intent.createChooser(shareIntent, "Share images to.."));
//分享富文本内容
Intent sendIntent = new Intent(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_TEXT, "Hello!");

// (Optional) Here we're setting the title of the content
sendIntent.putExtra(Intent.EXTRA_TITLE, "Send message");

// (Optional) Here we're passing a content URI to an image to be displayed
sendIntent.setData(contentUri);
    sendIntent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);

// Show the Sharesheet
startActivity(Intent.createChooser(sendIntent, null));
//使用intent解析器发送文本
Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_TEXT, "This is my text to send.");
sendIntent.setType("text/plain");
startActivity(sendIntent);
    
```

安卓发送简单数据时的一些常用的MIME类型

- `text/plain`、`text/rtf`、`text/html`、`text/json`，接收方应注册 `text/*`
- `image/jpg`、`image/png`、`image/gif`，接收方应注册 `image/*`
- `video/mp4`、`video/3gp`，接收方应注册 `video/*`
- `application/pdf`，接收方应注册支持的文件扩展名
- 您可以使用 MIME 类型的 `*/*`，但强烈建议您不要这样做，因为它仅与能够处理通用数据流的 Activity 匹配

三种从其他应用接收简单的数据

- 在清单中有匹配的 `intent-filter` 标记的 `Activity`
- 由您的 `ChooserTargetService` 返回的一个或多个 `ChooserTarget` 对象
- 您的应用发布的共享快捷方式。这些会取代 `ChooserTarget` 对象。只有当您的应用在 Android 10（API 级别 29）平台上运行时，才可以使用共享快捷方式。

使用`<intent-filter>`在`mainfest`定义一个intent过滤器。

```xml
<activity android:name=".ui.MyActivity" >
        <intent-filter>
            <action android:name="android.intent.action.SEND" />
            <category android:name="android.intent.category.DEFAULT" />
            <data android:mimeType="image/*" />
        </intent-filter>
        <intent-filter>
            <action android:name="android.intent.action.SEND" />
            <category android:name="android.intent.category.DEFAULT" />
            <data android:mimeType="text/plain" />
        </intent-filter>
        <intent-filter>
            <action android:name="android.intent.action.SEND_MULTIPLE" />
            <category android:name="android.intent.category.DEFAULT" />
            <data android:mimeType="image/*" />
        </intent-filter>
</activity>
    
```

如果要处理`Intent`传送的内容，调用`getIntent()`。注意一定要在主（“界面”）线程以外的独立线程中处理二进制数据。

```
    void onCreate (Bundle savedInstanceState) {
        ...
        // Get intent, action and MIME type
        Intent intent = getIntent();
        String action = intent.getAction();
        String type = intent.getType();

        if (Intent.ACTION_SEND.equals(action) && type != null) {
            if ("text/plain".equals(type)) {
                handleSendText(intent); // Handle text being sent
            } else if (type.startsWith("image/")) {
                handleSendImage(intent); // Handle single image being sent
            }
        } else if (Intent.ACTION_SEND_MULTIPLE.equals(action) && type != null) {
            if (type.startsWith("image/")) {
                handleSendMultipleImages(intent); // Handle multiple images being sent
            }
        } else {
            // Handle other intents, such as being started from the home screen
        }
        ...
    }

    void handleSendText(Intent intent) {
        String sharedText = intent.getStringExtra(Intent.EXTRA_TEXT);
        if (sharedText != null) {
            // Update UI to reflect text being shared
        }
    }

    void handleSendImage(Intent intent) {
        Uri imageUri = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);
        if (imageUri != null) {
            // Update UI to reflect image being shared
        }
    }

    void handleSendMultipleImages(Intent intent) {
        ArrayList<Uri> imageUris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
        if (imageUris != null) {
            // Update UI to reflect multiple images being shared
        }
    }
    
```

###### 分享文件

如果需要将应用中的文件提供给其他应用，唯一安全的做法是向接收方发送文件的内容URI,并授予对该URI的临时访问权限。`FileProvider`提供了`getUriFile()`方法，用于生成文件的内容URI。

在`Mainfest`清单文件中添加制定类、授权和元素。

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.example.myapp">
    <application
                 ...>
        <provider
                  android:name="androidx.core.content.FileProvider"
                  android:authorities="com.example.myapp.fileprovider"
                  android:grantUriPermissions="true"
                  android:exported="false">
            <meta-data
                       android:name="android.support.FILE_PROVIDER_PATHS"
                       android:resource="@xml/filepaths" />
        </provider>
        ...
    </application>
</manifest>
/*android:authorities 属性指定您希望用于由 FileProvider 生成的内容 URI 的 URI 授权。示例中的授权为 com.example.myapp.fileprovider。对于您自己的应用，请指定由应用的 android:package 值加上字符串“fileprovider”构成的授权值*/
//指定可共享目录
<paths>
    <files-path path="images/" name="myimages" />
</paths>
<files-path> 标记共享了应用内部存储空间的 files/ 目录中的目录。path 属性共享了 files/ 的 images/ 子目录。name 属性指示 FileProvider 将路径段 myimages 添加到 files/images/ 子目录中文件的内容 URI 中。
<paths> 元素可以有多个子元素，每个子元素指定一个不同的共享目录。除了 <files-path> 元素之外，您还可以使用 <external-path> 元素共享外部存储空间中的目录，使用 <cache-path> 元素共享内部缓存目录中的目录。    
```

创建文件选择Activity

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    ...
    <application>
        ...
        <activity
                  android:name=".FileSelectActivity"
                  android:label="@File Selector" >
            <intent-filter>
                <action
                        android:name="android.intent.action.PICK"/>
                <category
                          android:name="android.intent.category.DEFAULT"/>
                <category
                          android:name="android.intent.category.OPENABLE"/>
                <data android:mimeType="text/plain"/>
                <data android:mimeType="image/*"/>
            </intent-filter>
        </activity>
```

定义一个`Activity`子类显示应用内部存储空间`files/images`目录中的可用文件，并允许用户选取所需的文件。

```java
public class MainActivity extends Activity {
    // The path to the root of this app's internal storage
    private File privateRootDir;
    // The path to the "images" subdirectory
    private File imagesDir;
    // Array of files in the images subdirectory
    File[] imageFiles;
    // Array of filenames corresponding to imageFiles
    String[] imageFilenames;
    // Initialize the Activity
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
            // Set up an Intent to send back to apps that request a file
            resultIntent =
            new Intent("com.example.myapp.ACTION_RETURN_FILE");
        // Get the files/ subdirectory of internal storage
        privateRootDir = getFilesDir();
        // Get the files/images subdirectory;
        imagesDir = new File(privateRootDir, "images");
        // Get the files in the images subdirectory
        imageFiles = imagesDir.listFiles();
        // Set the Activity's result to null to begin with
        setResult(Activity.RESULT_CANCELED, null);
        /*
             * Display the file names in the ListView fileListView.
             * Back the ListView with the array imageFilenames, which
             * you can create by iterating through imageFiles and
             * calling File.getAbsolutePath() for each File
             */
        ...
    }
    ...
}

```

相应文件选择

用户选择共享文件后，您的应用必须确定用户选择了哪个文件，然后为该文件生成内容 URI。`Activity` 会在 `ListView` 中显示可用文件的列表，当用户点击文件名时，系统会调用方法 `onItemClick()`，以获取所选的文件。

```java
//检测所选文件并为其生成内容URI
protected void onCreate(Bundle savedInstanceState) {
    ...
        // Define a listener that responds to clicks on a file in the ListView
        fileListView.setOnItemClickListener(
        new AdapterView.OnItemClickListener() {
            @Override
            /*
                 * When a filename in the ListView is clicked, get its
                 * content URI and send it to the requesting app
                 */
            public void onItemClick(AdapterView<?> adapterView,
                                    View view,
                                    int position,
                                    long rowId) {
                /*
                     * Get a File for the selected file name.
                     * Assume that the file names are in the
                     * imageFilename array.
                     */
                File requestFile = new File(imageFilename[position]);
                /*
                     * Most file-related method calls need to be in
                     * try-catch blocks.
                     */
                // Use the FileProvider to get a content URI
                try {
                    fileUri = FileProvider.getUriForFile(
                        MainActivity.this,
                        "com.example.myapp.fileprovider",
                        requestFile);
                } catch (IllegalArgumentException e) {
                    Log.e("File Selector",
                          "The selected file can't be shared: " + requestFile.toString());
                }
                ...
            }
        });
    ...
}
```



```java
//设置文件的读取权限
        protected void onCreate(Bundle savedInstanceState) {
            ...
            // Define a listener that responds to clicks in the ListView
            fileListView.setOnItemClickListener(
                    new AdapterView.OnItemClickListener() {
                @Override
                public void onItemClick(AdapterView<?> adapterView,
                        View view,
                        int position,
                        long rowId) {
                    ...
                    if (fileUri != null) {
                        // Grant temporary read permission to the content URI
                        resultIntent.addFlags(
                            Intent.FLAG_GRANT_READ_URI_PERMISSION);
                    }
                    ...
                 }
                 ...
            });
        ...
        }

```



```java
//和请求方应用共享文件
protected void onCreate(Bundle savedInstanceState) {
    ...
        // Define a listener that responds to clicks on a file in the ListView
        fileListView.setOnItemClickListener(
        new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> adapterView,
                                    View view,
                                    int position,
                                    long rowId) {
                ...
                    if (fileUri != null) {
                        ...
                            // Put the Uri and MIME type in the result Intent
                            resultIntent.setDataAndType(
                            fileUri,
                            getContentResolver().getType(fileUri));
                        // Set the result
                        MainActivity.this.setResult(Activity.RESULT_OK,
                                                    resultIntent);
                    } else {
                        resultIntent.setDataAndType(null, "");
                        MainActivity.this.setResult(RESULT_CANCELED,
                                                    resultIntent);
                    }
            }
        });

```

为用户提供在选择文件后立即返回到客户端应用的方法。一种方式是提供复选标记或**完成**按钮。使用按钮的 `android:onClick` 属性将某个方法与按钮关联起来。在该方法中，调用 `finish()`。

```java
public void onDoneClick(View v) {
    // Associate a method with the Done button
    finish();
}
    
```

###### 发送文件请求

客户端应用需要使用 `Intent` 调用 `startActivityForResult`，该 Intent 包含 `ACTION_PICK` 等操作和客户端应用能够处理的 MIME 类型。

```java
//向服务器发送Intent以启动共享文件中所描述的Activity
public class MainActivity extends Activity {
        private Intent requestFileIntent;
        private ParcelFileDescriptor inputPFD;
        ...
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
            requestFileIntent = new Intent(Intent.ACTION_PICK);
            requestFileIntent.setType("image/jpg");
            ...
        }
        ...
        protected void requestFile() {
            /**
             * When the user requests a file, send an Intent to the
             * server app.
             * files.
             */
                startActivityForResult(requestFileIntent, 0);
            ...
        }
        ...
}
```

```java
/*
* When the Activity of the app that hosts files sets a result and calls
* finish(), this method is invoked. The returned Intent contains the
* content URI of a selected file. The result code indicates if the
* selection worked or not.
 /
@Override
public void onActivityResult(int requestCode, int resultCode,
                             Intent returnIntent) {
    // If the selection didn't work
    if (resultCode != RESULT_OK) {
        // Exit without doing anything else
        return;
    } else {
        // Get the file's content URI from the incoming Intent
        Uri returnUri = returnIntent.getData();
        /*
                 * Try to open the file for "read" access using the
                 * returned URI. If the file isn't found, write to the
                 * error log and return.
                 */
        try {
            /*
                     * Get the content resolver instance for this context, and use it
                     * to get a ParcelFileDescriptor for the file.
                     */
            inputPFD = getContentResolver().openFileDescriptor(returnUri, "r");
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            Log.e("MainActivity", "File not found.");
            return;
        }
        // Get a regular file descriptor for the file
        FileDescriptor fd = inputPFD.getFileDescriptor();
        ...
    }
}
// 客户端应用如何处理服务器应用发送的 Intent，以及如何使用内容 URI 获取 FileDescriptor：
```



```java
...
    /*
         * Get the file's content URI from the incoming Intent, then
         * get the file's MIME type
         */
    Uri returnUri = returnIntent.getData();
String mimeType = getContentResolver().getType(returnUri);
...
    //客户端应用如何在服务器应用向客户端发送内容 URI 后检索文件的 MIME 类型：
```

`FileProvider`类默认实现`query()`，返回Cursor中的那日哦那个URI关联的文件的名称`DISPLAY_NAME`和大小`SIZE`。

```java
        ...
        /*
         * Get the file's content URI from the incoming Intent,
         * then query the server app to get the file's display name
         * and size.
         */
        Uri returnUri = returnIntent.getData();
        Cursor returnCursor =
                getContentResolver().query(returnUri, null, null, null, null);
        /*
         * Get the column indexes of the data in the Cursor,
         * move to the first row in the Cursor, get the data,
         * and display it.
         */
        int nameIndex = returnCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);
        int sizeIndex = returnCursor.getColumnIndex(OpenableColumns.SIZE);
        returnCursor.moveToFirst();
        TextView nameView = (TextView) findViewById(R.id.filename_text);
        TextView sizeView = (TextView) findViewById(R.id.filesize_text);
        nameView.setText(returnCursor.getString(nameIndex));
        sizeView.setText(Long.toString(returnCursor.getLong(sizeIndex)));
        ...
```

###### **内容提供程序**

一种标准接口，可将一个进程中的数据与另一个进程中运行的代码进行连接

<center class="">
    <img src="pics\ContenProvider.png" width="40%" alt ="content Provider"/>
    <img src="pics\ContentProvider.png" width="44%" alt ="content Provider"/>
<center>
Content provider作用




- 与其他应用共享对应用数据的访问

- 向Widget发送数据
- 使用 SearchRecentSuggestionsProvider，通过搜索框架返回对应用的自定义搜索建议
- 通过实现 AbstractThreadedSyncAdapter，将应用数据与服务器同步
- 使用 CursorLoader 在界面中加载数据

 <img src="C:/Users/80303888/Desktop/gukkidocs/hiandroid/pics/ContentProvider1.png" width="50%" alt ="content Provider1"/>

<img src="C:/Users/80303888/Desktop/gukkidocs/hiandroid/pics/content-provider-interaction.png" width = "30%" alt="content-provider-interactions"/>

实现`ContentProvider`类

必需方法`query()` `insert()`  `update` `delete()` `getType()` `onCrete()`

应用安装位置

如果要把应用安装到外部存储装置中，可以声明`android:installLoaction`属性，该属性的值为`prefer	External`或者`auto`



